import { ByteInstruction, ByteOperation, ByteProgram, CallFrame, CallableChunk, ConcreteValue, StackValue, ThunkValue } from "../types/byteCode";
import { assertDef, assertNever, assertTruthy } from "../utils";

const makeConcrete = (
    value: ConcreteValue['value'], dataType: ConcreteValue['dataType']
): ConcreteValue => ({ type: 'concrete', dataType, value });
const makeThunk = (
    args: ThunkValue['args'], chunk: ThunkValue['chunk'], label: string,
): ThunkValue => ({ type: 'thunk', args, chunk, label, result: null });

export class StackMachine {
    stack: StackValue[] = [];
    callStack: CallFrame[] = [];

    constructor(
        private program: ByteProgram,
    ) {}

    reset() {
        this.stack = [];
        this.callStack = [];
    }

    interpret(entryLabel: string) {
        try {
            this.callChunk(entryLabel, this.getChunk(entryLabel));

            while (this.callStack.length) {
                while (this.callStack.length) {
                    const scope = this.callStack.at(-1)!;
                    // assertTruthy(0 <= scope.ip && scope.ip < scope.chunk.instructions.length,
                    //     `Instruction pointer out of bounds: ${scope.ip}, chunk size: ${scope.chunk.instructions.length}.`);
                    const instr = 
                        scope.chunk.instructions[scope.ip]
                        || { type: 'operation', operation: ByteOperation.return };

                    scope.ip++;
                    this.runInstruction(instr);
                }

                if (this.dget(0).type === 'thunk') {
                    this.scheduleEvaluateThunk(0);
                }
            }
        } catch (e: any) {
            let callStackLines: string[] = [];
            for (let i = this.callStack.length - 1; i >= 0; i--) {
                const node = this.callStack[i];
                callStackLines.push(`    ${node.label}:${node.ip - 1}`);
            }
            e.message += '\n'
            e.message += callStackLines.join('\n');
            throw e;
        }
    }

    runInstruction(instr: ByteInstruction) {
        if (instr.type === 'data') {
            this.dpush(instr.data);
        } else {
            this.runOperation(instr.operation);
        }
    }

    runOperation(op: ByteOperation) {
        switch (op) {
            case ByteOperation.bneg:
            case ByteOperation.nneg:
            case ByteOperation.ncmpz:
            case ByteOperation.ncmpnz:
            case ByteOperation.ntrunc:
                this.runOrExtendThunk(1, op);
                break;
            case ByteOperation.nadd:
            case ByteOperation.nsub:
            case ByteOperation.nmul:
            case ByteOperation.ndiv:
            case ByteOperation.ngt:
            case ByteOperation.nlt:
            case ByteOperation.ncmp:
            case ByteOperation.band:
            case ByteOperation.bor:
            case ByteOperation.sconcat:
            case ByteOperation.oget:
            case ByteOperation.aget:
            case ByteOperation.aconcat:
                this.runOrExtendThunk(2, op);
                break;
            case ByteOperation.ssub:
            case ByteOperation.asub:
                this.runOrExtendThunk(3, op);
                break;

            // NON-THUNKABLE OPS
            case ByteOperation.dup:
                this.dpush(this.dget(0)); break;
            case ByteOperation.pop:
                this.dpop(); break;
            case ByteOperation.swp: {
                const t0 = this.dpop()!;
                const t1 = this.dpop()!;
                this.dpush(t0);
                this.dpush(t1);
                break;
            }
            case ByteOperation.return:
                this.returnCall();
                break;

            case ByteOperation.narg:
            case ByteOperation.barg:
            case ByteOperation.sarg:
            case ByteOperation.oarg:
            case ByteOperation.call:
            case ByteOperation.j:
                this.runOrEvaluateThunk(1, op);
                break;
            case ByteOperation.jc:
                this.runOrEvaluateThunk(2, op);
                break;

            default:
                assertNever(`Unknown op '${op}'`);
        }
    }

    runOrExtendThunk(numArgs: number, op: ByteOperation) {
        let hasThunk = false;
        for (let i = 0; i < numArgs; i++) {
            hasThunk ||= this.dget(i).type === 'thunk';
        }

        if (hasThunk) {
            const args: StackValue[] = [];
            for (let i = 0; i < numArgs; i++) {
                args.push(this.dpop());
            }
            const thunkChunk: CallableChunk = {
                arity: numArgs,
                instructions: [{ type: 'operation', operation: op }],
            };
            this.dpush(makeThunk(args, thunkChunk, 'Combined thunk'))
            return;
        }

        // here, no thunks
        const res = this.evaluateConcreteOperation(op);
        if (res != null) {
            this.dpush(res);
        }
    }

    runOrEvaluateThunk(evaluateFirstN: number, op: ByteOperation) {
        for (let i = 0; i < evaluateFirstN; i++) {
            const arg = this.dget(i);
            if (arg.type === 'thunk') {
                this.currScope().ip--; // instruction must be rerun afterwards
                this.scheduleEvaluateThunk(i);
                return;
            }
        }
        // here, all args are not thunks
        const res = this.evaluateConcreteOperation(op);
        if (res != null) {
            this.dpush(res);
        }
    }

    scheduleEvaluateThunk(stackIndex: number) {
        const thunk = this.dget(stackIndex) as ThunkValue;
        assertTruthy(thunk.type === 'thunk');

        this.callChunk(thunk.label, thunk.chunk, stackIndex);

        // pop thunk
        this.dpop();
        // add args 
        for (let i = thunk.args.length - 1; i >= 0; i--) {
            this.dpush(thunk.args[i]);
        }
    }

    evaluateConcreteOperation(op: ByteOperation): StackValue | null {
        switch (op) {
            case ByteOperation.nop:
                return this.dpop();
            case ByteOperation.bneg:
                return makeConcrete(
                    !<boolean>this.unpack(this.dpop(), 'boolean'), 'boolean');
            case ByteOperation.nneg:
                return makeConcrete(
                    -<number>this.unpack(this.dpop(), 'number'), 'number');
            case ByteOperation.ncmpz:
                return makeConcrete(this.unpack(this.dpop(), 'number') === 0, 'boolean');
            case ByteOperation.ncmpnz:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') !== 0, 'boolean');
            case ByteOperation.ntrunc:
                return makeConcrete(
                    Math.floor(<number>this.unpack(this.dpop(), 'number')), 'number');
            case ByteOperation.nadd:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') + <number>this.unpack(this.dpop(), 'number'), 'number');
            case ByteOperation.nsub:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') - <number>this.unpack(this.dpop(), 'number'), 'number');
            case ByteOperation.nmul:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') * <number>this.unpack(this.dpop(), 'number'), 'number');
            case ByteOperation.ndiv:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') / <number>this.unpack(this.dpop(), 'number'), 'number');
            case ByteOperation.ngt:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') > <number>this.unpack(this.dpop(), 'number'), 'boolean');
            case ByteOperation.nlt:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') < <number>this.unpack(this.dpop(), 'number'), 'boolean');
            case ByteOperation.ncmp:
                return makeConcrete(
                    <number>this.unpack(this.dpop(), 'number') === <number>this.unpack(this.dpop(), 'number'), 'boolean');
            case ByteOperation.band:
                return makeConcrete(
                    <boolean>this.unpack(this.dpop(), 'boolean') && <boolean>this.unpack(this.dpop(), 'boolean'), 'boolean');
            case ByteOperation.bor:
                return makeConcrete(
                    <boolean>this.unpack(this.dpop(), 'boolean') || <boolean>this.unpack(this.dpop(), 'boolean'), 'boolean');
            case ByteOperation.ssub: {
                const str = <string>this.unpack(this.dpop(), 'string');
                const start = <number>this.unpack(this.dpop(), 'number');
                const len = <number>this.unpack(this.dpop(), 'number');
                return makeConcrete(
                    str.slice(start, Math.max(0, start + len)), 'string');
            }
            // case ByteOperation.sconcat:
            //     this.dpush( this.dpop<string>('s') + this.dpop('s') );
            //     break;
            // // ARRAYS
            // case ByteOperation.aget: {
            //     const index = this.dpop('n');
            //     this.dpush(this.dpop('a').at(index));
            //     break;
            // }
            // case ByteOperation.aconcat:
            //     this.dpush( this.dpop<any[]>('a').concat(this.dpop('a')) );
            //     break;
            // case ByteOperation.asub: {
            //     const arr = this.dpop<any[]>('a');
            //     const start = this.dpop<number>('n');
            //     const len = this.dpop<number>('n');
            //     this.dpush(arr.slice(start, Math.max(0, start + len)));
            //     break;
            // }
            // // OBJECTS
            // case ByteOperation.oget: {
            //     const propKey = this.dpop();
            //     const obj = this.dpop('o');
            //     this.dpush(obj[propKey]);
            //     break;
            // }

            case ByteOperation.narg:
                return this.checkType(this.getNthScopeElement(
                    <number>this.unpack(this.dpop(), 'number')), 'number');
            case ByteOperation.iarg:
                return this.checkType(this.getNthScopeElement(
                    <number>this.unpack(this.dpop(), 'number')), 'integer');
            case ByteOperation.barg:
                return this.checkType(this.getNthScopeElement(
                    <number>this.unpack(this.dpop(), 'number')), 'boolean');
            case ByteOperation.sarg:
                return this.checkType(this.getNthScopeElement(
                    <number>this.unpack(this.dpop(), 'number')), 'string');
            case ByteOperation.aarg:
                return this.checkType(this.getNthScopeElement(
                    <number>this.unpack(this.dpop(), 'number')), 'array');
            case ByteOperation.oarg:
                return this.checkType(this.getNthScopeElement(
                    <number>this.unpack(this.dpop(), 'number')), 'object');

            case ByteOperation.call: {
                const label = <string>this.unpack(this.dpop(), 'string');
                const chunk = this.getChunk(label);
                const args: StackValue[] = [];
                for (let a = 0; a < chunk.arity; a++) {
                    args.push(this.dpop());
                }
                return makeThunk(args, chunk, `${label} (thunk)`);
            }
            case ByteOperation.j:
                this.currScope().ip += <number>this.unpack(this.dpop(), 'integer');
                return null;
            case ByteOperation.jc: {
                const addr = <number>this.unpack(this.dpop(), 'integer');
                const condition = <boolean>this.unpack(this.dpop(), 'boolean');
                if (condition) {
                    this.currScope().ip += addr;
                }
                return null;
            }
        }

        assertNever(`Unknown op '${op}'.`);
    }

    // runInstruction(instr: ByteInstruction) {
    //     if (instr.type === 'data') {
    //         this.dpush(instr.data);
    //         return;
    //     }

    //     switch (instr.operation) {
    //         // DATA
    //         case ByteOperation.bneg:
    //             this.dpush(!this.dpop('b')); break;
    //         case ByteOperation.nneg:
    //             this.dpush(-this.dpop('n')); break;
    //         case ByteOperation.ncmpz:
    //             this.dpush(this.dpop('n') === 0); break;
    //         case ByteOperation.ncmpnz:
    //             this.dpush(this.dpop('n') !== 0); break;
    //         case ByteOperation.ntrunc:
    //             this.dpush(Math.floor(this.dpop('n'))); break;
    //         case ByteOperation.nadd:
    //             this.dpush(this.dpop('n') + this.dpop('n')); break;
    //         case ByteOperation.nsub:
    //             this.dpush(this.dpop('n') - this.dpop('n')); break;
    //         case ByteOperation.nmul:
    //             this.dpush(this.dpop('n') * this.dpop('n')); break;
    //         case ByteOperation.ndiv:
    //             this.dpush(this.dpop('n') / this.dpop('n')); break;
    //         case ByteOperation.ngt:
    //             this.dpush(this.dpop('n') > this.dpop('n')); break;
    //         case ByteOperation.nlt:
    //             this.dpush(this.dpop('n') < this.dpop('n')); break;
    //         case ByteOperation.ncmp:
    //             this.dpush(this.dpop('n') === this.dpop('n')); break;
    //         case ByteOperation.band:
    //             this.dpush(this.dpop('b') && this.dpop('b')); break;
    //         case ByteOperation.bor:
    //             this.dpush(this.dpop('b') || this.dpop('b')); break;
    //         case ByteOperation.ssub: {
    //             const str = this.dpop<string>('s');
    //             const start = this.dpop<number>('n');
    //             const len = this.dpop<number>('n');
    //             this.dpush(str.slice(start, Math.max(0, start + len)));
    //             break;
    //         }
    //         case ByteOperation.sconcat:
    //             this.dpush( this.dpop<string>('s') + this.dpop('s') );
    //             break;
    //         // // arrays
    //         // case ByteOperation.apack:
    //         //     const n = this.dpop<number>('n');
    //         //     const arr: any[] = [];
    //         //     for (let i = 0; i < n; i++) {
    //         //         arr.push(this.dpop());
    //         //     }
    //         //     this.dpush(arr);
    //         //     break;
    //         case ByteOperation.aget: {
    //             const index = this.dpop('n');
    //             this.dpush(this.dpop('a').at(index));
    //             break;
    //         }
    //         case ByteOperation.aconcat:
    //             this.dpush( this.dpop<any[]>('a').concat(this.dpop('a')) );
    //             break;
    //         case ByteOperation.asub: {
    //             const arr = this.dpop<any[]>('a');
    //             const start = this.dpop<number>('n');
    //             const len = this.dpop<number>('n');
    //             this.dpush(arr.slice(start, Math.max(0, start + len)));
    //             break;
    //         }
    //         // // objects
    //         // case ByteOperation.opack: {
    //         //     // expects: [ n, key_1, value_1, ... , key_n, value_n ]
    //         //     // returns: [ { key_1: value_1, ... } ]
    //         //     const n = this.dpop<number>('n');
    //         //     const obj: any = {};
    //         //     for (let i = 0; i < n; i++) {
    //         //         const key = this.dpop('s');
    //         //         const element = this.dpop();
    //         //         obj[key] = element;
    //         //     }
    //         //     this.dpush(obj);
    //         //     break;
    //         // }
    //         case ByteOperation.oget: {
    //             const propKey = this.dpop();
    //             const obj = this.dpop('o');
    //             this.dpush(obj[propKey]);
    //             break;
    //         }

    //         // STACK & SCOPE
    //         case ByteOperation.dup:
    //             this.dpush(this.dget(0)); break;
    //         case ByteOperation.pop:
    //             this.dpop(); break;
    //         case ByteOperation.swp: {
    //             const t0 = this.dpop()!;
    //             const t1 = this.dpop()!;
    //             this.dpush(t0);
    //             this.dpush(t1);
    //             break;
    //         }
    //         case ByteOperation.narg:
    //             this.dpush(this.assertDataType(
    //                 this.getNthScopeElement(this.dpop('n')), 'n'));
    //             break;
    //         case ByteOperation.barg:
    //             this.dpush(this.assertDataType(
    //                 this.getNthScopeElement(this.dpop('n')), 'b'));
    //             break;
    //         case ByteOperation.sarg:
    //             this.dpush(this.assertDataType(
    //                 this.getNthScopeElement(this.dpop('n')), 's'));
    //             break;
    //         case ByteOperation.oarg:
    //             this.dpush(this.assertDataType(
    //                 this.getNthScopeElement(this.dpop('n')), 'o'));
    //             break;

    //         // CONTROL FLOW
    //         case ByteOperation.call:
    //             this.callChunk(
    //                 this.getChunk(this.dpop<string>('s')));
    //             break;
    //         case ByteOperation.return:
    //             this.returnCall();
    //             break;
    //         case ByteOperation.j:
    //             this.currScope().ip += this.dpop('i');
    //             break;
    //         case ByteOperation.jc: {
    //             const addr = this.dpop('i');
    //             const condition = this.dpop('b');
    //             if (condition) {
    //                 this.currScope().ip += addr;
    //             }
    //             break;
    //         }
    //         default:
    //             assertNever(`Unknown instruction '${JSON.stringify(instr)}'`);
    //     }
    // }

    getChunk(label: string) {
        return assertDef(this.program.chunks.get(label), `Could not find chunk with label '${label}'`);
    }
    callChunk(label: string, chunk: CallableChunk, deferFirstN = 0) {
        if (this.callStack.length >= 100000) {
            assertNever(`Stack overflow (call stack has ${this.callStack.length} entries).`);
        }
        // defer unused args from top
        const deferredScopeTop = this.stack.splice(-deferFirstN, deferFirstN);
        // after defering, remember length without args
        const scopeStartIndex = this.stack.length - chunk.arity;

        this.callStack.push({
            label,
            chunk,
            ip: 0,
            stackBase: scopeStartIndex,
            deferredScopeTop,
        });
        // for (let i = 0; i < chunk.locals; i++) {
        //     this.dpush(makeConcrete(0, 'number')); // making room for locals
        // }
    }
    returnCall() {
        // returnvalue is expected to be at top
        const returnValue = this.dpop();
        // remove rest of stack from top scope
        const scopeToReturn = assertDef(this.callStack.pop(), 'Cannot pop call stack');
        this.stack = this.stack.slice(0, scopeToReturn.stackBase);
        // add return value
        this.dpush(returnValue);
        // add back stack from temp storage
        this.stack.push(...scopeToReturn.deferredScopeTop);
    }
    currScope() {
        return assertDef(this.callStack.at(-1), 'Call stack is empty.');
    }
    getNthScopeElement(index: number) {
        const { stackBase: scopeStartIndex } = this.currScope();
        const argIndex = scopeStartIndex + index;
        assertTruthy(scopeStartIndex <= argIndex && argIndex < this.stack.length,
            'Scope element index out of bounds');
        return this.stack[argIndex];
    }

    unpack<T>(value: StackValue, expectedType: ConcreteValue['dataType']) {
        return this.checkType(value, expectedType).value;
    }
    checkType(value: StackValue, expectedType: ConcreteValue['dataType']): ConcreteValue {
        if (value.type !== 'concrete') {
            throw new Error(`Expected concrete type.`);
        }
        assertTruthy(value.dataType === expectedType,
            `Expected value of type '${expectedType}', received '${value.dataType}'.`);
        return value;
    }

    dget(index: number) {
        assertTruthy(0 <= index && index < this.stack.length,
            `Value stack index out of bounds '${index}'.`);
        const x = this.stack[this.stack.length - 1 - index];
        return x;
    }
    dpop() {
        const x = assertDef(this.stack.pop(), 'Data stack is empty.');
        return x;
    }
    dpush(d: StackValue) { this.stack.push(d); }
}
