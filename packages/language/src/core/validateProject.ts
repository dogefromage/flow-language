import { baseEnvironmentContent } from "../content/base";
import { AutoGeneratedSignatures, FlowEntryPoint, FlowEnvironmentContent, FlowGraph, FlowSignature, InputRowSignature, OutputRowSignature, autoGeneratedPrefix, createAutoGeneratedId } from "../types";
import { FlowGraphContext, ProjectContext } from "../types/context";
import { Obj } from "../types/utilTypes";
import { deepFreeze } from "../utils";
import DependencyGraph from "../utils/DependencyGraph";
import { memoizeMulti } from "../utils/functional";
import { createEnvironment, pushContent } from "./environment";
import { collectFlowDependencies, validateFlowGraph } from "./validateFlowGraph";

export function validateProject(
    flowGraphs: Obj<FlowGraph>,
    // content: FlowEnvironmentContent,
    entryPoints: Obj<FlowEntryPoint>,
): ProjectContext {
    const result: ProjectContext = {
        ref: flowGraphs,
        flowContexts: {},
        problems: [],
        topologicalFlowOrder: [],
        entryPointDependencies: {},
    }

    const signatureDeps = new DependencyGraph<string>();

    for (const flow of Object.values(flowGraphs)) {
        const flowDependencies = collectFlowDependencies(flow);
        signatureDeps.addDependencies(flow.id, flowDependencies);
        // add every dependency, also built-in ones
    }

    const topSortResult = signatureDeps.sortTopologically();
    if (topSortResult.cycles.length) {
        result.problems.push({
            type: 'cyclic-flows',
            cycles: topSortResult.cycles,
        });
    }
    result.topologicalFlowOrder = topSortResult.bottomToTopDependencies;

    for (const [entryId, entryPoint] of Object.entries(entryPoints)) {
        const topFlow = flowGraphs[entryPoint.entryFlowId];
        if (topFlow == null) {
            result.problems.push({
                type: 'missing-top-flow',
                id: entryPoint.entryFlowId,
            });
        } else {
            const depsRecursive = signatureDeps.findDependenciesRecursive(entryPoint.entryFlowId);
            result.entryPointDependencies[entryId] = [ ...depsRecursive ];
        }
    }

    let currentEnvironment = createEnvironment(baseEnvironmentContent);

    for (const flowId of topSortResult.bottomToTopDependencies) {
        const flow = flowGraphs[flowId];
        if (!flow) {
            continue;
        }
        const flowSyntaxContent = generateFlowSyntaxLayer(flow.inputs, flow.outputs);
        const flowSyntaxEnv = pushContent(currentEnvironment, flowSyntaxContent);
        const flowContext = validateFlowGraph(flow, flowSyntaxEnv);
        result.flowContexts[flowId] = flowContext;

        // extend environment
        currentEnvironment = pushContent(currentEnvironment, flowSignatureContent(flowContext))
    }

    deepFreeze(result);
    return result;
};

const flowSignatureContent = memoizeMulti(
    (flowContext: FlowGraphContext): FlowEnvironmentContent => ({
        signatures: { [flowContext.ref.id]: flowContext.flowSignature },
        types: {},
    })
);

const generateFlowSyntaxLayer = memoizeMulti(generateFlowSyntaxLayerInitial);
function generateFlowSyntaxLayerInitial(
    flowInputs: InputRowSignature[],
    flowOutputs: OutputRowSignature[],
): FlowEnvironmentContent {
    const input: FlowSignature = {
        id: createAutoGeneratedId(AutoGeneratedSignatures.Input),
        name: 'Input',
        description: null,
        attributes: { category: 'In/Out' },
        inputs: [],
        outputs: flowInputs.map(o => ({
            id: o.id,
            label: o.label,
            dataType: o.dataType,
            rowType: 'output',
            initializer: false,
        })),
    }
    const output: FlowSignature = {
        id: createAutoGeneratedId(AutoGeneratedSignatures.Output),
        name: 'Output',
        description: null,
        attributes: { category: 'In/Out' },
        inputs: flowOutputs.map(o => ({
            id: o.id,
            label: o.label,
            dataType: o.dataType,
            rowType: 'input-simple',
            initializer: false,
        })),
        outputs: [],
    }
    const signatures = Object.fromEntries([input, output].map(sig => [sig.id, sig]));
    return {
        signatures,
        types: {},
    }
}
